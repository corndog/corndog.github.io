<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">

		<title>Introduction to Implicits in Scala</title>

		<meta name="description" content="Introduction to Implicits in Scala">
		<meta name="author" content="Hugh Richardson">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/css/reveal.min.css">
		<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/css/theme/solarized.css" id="theme">
		<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/lib/css/zenburn.css">
	</head>

	<body>
		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<!-- INTRO -->
				<section>
					<h1>Implicits in Scala</h1>
					<h3>An Introduction to How and Why</h3>
					<h4>A fancy quote from someone</h4>
					<hr size="5" style="background-color:black">
				</section>

				<!-- but first: multiple parameter lists -->
				<section>
					<p>but first
					<h3>Multiple Parameter Lists</h3>
					<div class="fragment">
						<p> You can do
						<div><pre><code data-trim>
def func(x: Int, y: Int): Int = x * y
or
def func(x: Int)(y: Int): Int = x * y
						</code></pre></div>
					</div>

					<div class="fragment">
						<p>Or
							<div><pre><code data-trim>
def func(a: Int, b: Int, c: Int, d: Int, e: Int) = ???
or
def func(a: Int)(b: Int)(c: Int)(d: Int)(e: Int) = ???
or
def func(a: Int, b: Int, c: Int)(d: Int, e: Int) = ???
							</code></pre><div>

							<p>You can divide up your arguments into separate groups.
							<hr size="5" style="background-color:black">
						</div>

				</section>


				<!-- Implicit Parameters- basics -->
				<section>
						<h3>Implicit Parameters</h3>
						
						<div class="fragment">
							<pre><code data-trim>
def func(x: Int)(y: Int): x * y
							</code></pre>
							<pre><code data-trim>
func(3)(4) = 12
func(3) = // uh oh: error: missing arguments for method func
							</code></pre>
						</div>
						

						<div class="fragment">
							<pre><code data-trim>
implicit val a: Int = 2
def func(x: Int)(implicit y: Int) = x * y
							</code></pre>
							<pre><code data-trim>
func(3)(4) = 12
func(3) = 6
							</code></pre>
						</div>

						<div class="fragment">
							<p>If a parameter is marked implicit, if you leave it out the compiler will look for a value of that type marked as implicit and insert it for you.
						</div>
						<div class="fragment"> 
							<pre><code data-trim>
func(3)
becomes 
func(3)(2)
							</code></pre>
							<hr size="5" style="background-color:black">
						</div>

				</section>

				<!-- bad things: can't have two implicit values of same type in same place -->


				<!-- Implicit conversions -->
				<section>
						<h3>Implicit conversions</h3>

						<div class="fragment">
							<div><pre><code data-trim>
implicit def arbitraryStringToInt(str: String): Int = str.length * 10
def func(x: Int): Int = x + 1
							</code></pre></div>
							<pre><code data-trim>
func(5) = 6
func("cat") = 31
							</code></pre>
						</div>
				
						<div class="fragment">
							<p>If you call a method with a parameter of the wrong type, the compiler will try and find an implicit conversion from the type you are providing to the type expected by the method, and insert the call to that function.
						</div>
						<div class="fragment">
							<pre><code data-trim>
func("cat")
becomes
func(arbitraryStringToInt("cat"))
							</code></pre>
						<hr size="5" style="background-color:black">
						</div>

			</section>

			<!-- pimp my library -->
			<section>
				<h3>Enrichments</h3>

					<div class="fragment">
						<p>What if wanted to do this?
						<div><pre><code data-trim>
5.isEven  (false)
						</code></pre></div>
						<p>Or
						<div><pre><code data-trim>
6 times 7  (42)
						</code></cpre></div>
					</div>

					<div class="fragment">
						<div><pre><code data-trim>
class SuperInt(x: Int) {
	def isEven: Boolean = x % 2 == 0
}
implicit def intToSuperInt(x: Int): SuperInt = new SuperInt(x)
						</code></pre></div>
						<pre><code data-trim>
5.isEven 
res1: Boolean = false
						</code></pre>
					</div>

				<div class="fragment">
					<p>If you invoke a method on an object and that object doesn't have that method, compiler looks for an implicit conversion from that obect type to one that does have the method.
					<hr size="5" style="background-color:black">
				</div>

			</section>

			<!-- pimp my library part 2-->
			<section>
				<h3>Enrichments ...</h3>
					<div class="fragment">
						<pre><code data-trim>
implicit class SuperInt(x: Int) {
	def isEven: Boolean = x % 2 == 0
	def isOdd: Boolean = !isEven
	def times(y: Int): Int = x * y
}
						</code></pre>
						<pre><code data-trim>
7.isOdd 
res1: Boolean = true
6 times 7 
res2: Int = 42
						</code></pre>
					</div>

				<div class="fragment">
					<p>If you invoke a method on an object and that object doesn't have that method, compiler looks for an implicit class that has the method.
					<hr size="5" style="background-color:black">
				</div>
				
			</section>

			<!-- Simpler why's ...  -->
			<section>
					<h3>Why</h3>
					<p>Lots of syntactic sugar/helpers in scala are implemented this way. See Predef for examples.
					<p>1 to 5  =  Range(1, 2, 3, 4, 5) <br /> from implicit def intWrapper(x: Int): RichInt
					<p>"cats".map(_.toUpper) = "CATS" <br />  from implicit def augmentString(x: String): StringOps
				
				<hr size="5" style="background-color:black">
			</section>


			<!-- A sort of unification, implicit values and parameters revisited - typeclasses and context bounds -->
			<section>
				<h3>Typeclass Pattern</h3>
				<div>What if we want to provide similar "enrichments" across multiple types?  E.g. json.</div>
				<div class="fragment">
					<pre><code data-trim>
trait Feature[T] {
	def impl(x: T): ??
}

implicit object IntFeature extends Feature[Int] {
	def impl(x: Int) : ???
}
					</code></pre>
				</div>

				<div class="fragment">
					<pre><code data-trim>
trait Feature[T] {
	def impl(x: T): Unit
}

implicit object IntFeature extends Feature[Int] {
	def impl(x: Int) : println(s"int feature for $x")
}
					</code></pre>
				</div>

				<div class="fragment">
					<pre><code data-trim>
val intF = implicitly[Feature[Int]]
intF.impl(5) // int feature for 5
					</code></pre>
					<hr size="5" style="background-color:black">
				</div>
			</section>

			<section>
				<h3>Typeclass Pattern ...</h3>
				<div class="fragment">
					<pre><code data-trim>
case class MyClass(i: Int, s: String)

implicit object MyClassFeature extends Feature[MyClass] {
	def impl(x: MyClass) = println(s"feature for MyClass ${x.i}, ${x.s}")
}
					</code></pre>
				</div>

				<div class="fragment"><div class="fragment">
					<pre><code data-trim>
def usesFeature[T](x: T)(implicit evidence: Feature[T]) = evidence.impl(x)
					</code></pre>
				</div>

				<div class="fragment">
					<pre><code data-trim>
usesFeature(5)
// feature for 5
usesFeature(MyClass(9, "bananas"))
// feature for MyClass 9 bananas
					</code></pre>
				</div>

				<div class="fragment">
					<p>Evidence?  The existence of an implicit value of type Feature[T] provides evidence that we can provide the feature for type T...
					<hr size="5" style="background-color:black">
				</div>

			</section>

			<section>
				<h3>Typeclass Pattern ...</h3>
				<div class="fragment">
					<pre><code data-trim>
usesFeature(MyClass(9, "bananas"))
// feature for MyClass 9 bananas
usesFeature(List(1,2))
// error: could not find implicit value for parameter evidence: Feature[List[Int]]
					</code></pre>
					<hr size="5" style="background-color:black">
				</div>

			</section>

			<section>
				<h3>Context Bounds</h3>
				<div class="fragment">
					<pre><code data-trim>
def checkFeature[T : Feature](x: T): T = x
					</code></pre>
				</div>

				<div class="fragment">
					<pre><code data-trim>
checkFeature(7)
// 7
checkFeature(9.99)
// error: cound not find implicit value for evidence parameter of type Feature[Double]
					</code></pre>
				</div>

			<div class="fragment">
				This
					<pre><code data-trim>
def checkFeature[T : Feature](x: T): T = x
					</code></pre>
				Is just syntactic suger for
					<pre><code data-trim>
def checkFeature[T](x: T)(implicit ev: Feature[T]): T = x
					</code></pre>
			</div>
		</section>

			<!-- end -->
			</div>
		</div>


		<script src="http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/lib/js/head.min.js"></script>
		<script src="http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/js/reveal.min.js"></script>

		<script>
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				overview: true,
				touch: true,
				theme: 'solarized',
				transition: 'slide', // none/fade/slide/convex/concave/zoom
				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',
				dependencies: [
					{ 
						src: 'http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/lib/js/classList.js', 
						condition: function() { return !document.body.classList; } 
					},
					{
						src: 'http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/plugin/markdown/marked.js', 
						condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ 
						src: 'http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/plugin/markdown/markdown.js', 
						condition: function() { return !!document.querySelector( '[data-markdown]' ); } 
					},
					{ 
						src: 'http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/plugin/highlight/highlight.js', 
						async: true, 
						callback: function() { hljs.initHighlightingOnLoad(); } 
					}
				]
			});
		</script>
	</body>
</html>


